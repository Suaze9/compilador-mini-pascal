import java_cup.runtime.*;

terminal String CONSTSTR, CONSTCHAR, NUMS;
terminal PROGRAM, FUNCTION, PROCEDURE, DO, VAR, BEGIN, END, FOR,
    WHILE, REPEAT, IF, ELSE, TRUE,
    FALSE, PARIZQ, READ, WRITE,
    PARDER, OPSUM, OPMULT, OPAND, OPOR, OPREL, ASSIG,
    COLON, INT, CHAR, BOOLEAN, RECORD, STRING, THEN,
    TO, UNTIL, ID, COMA, NOT;
        
non terminal Object test;
//non terminal Integer math, sum, mult, num, mathpar;                 //math operations ORIGINAL
non terminal Object math, sum, num, mathpar;
non terminal Object mult;         //Math multiplication operations, returns a MathMultNode for AST
non terminal Object bool, boolmath, rel, booland, boolor;  //boolean operations
non terminal Object statement;          //Statement
non terminal Object statementlist;      //Statement List
non terminal Object if;                 //If block
non terminal Object while;              //While cycle
non terminal Object for;                //For cycle
non terminal Object repeat;             //repeat cycle
non terminal Object read;               //read function
non terminal Object write;              //write function
non terminal Object decl;               //variable declaration
non terminal Object multdecl;           //multiple variable declaration
non terminal Object assig;              //assign value to variable
non terminal Object program;            //program start
non terminal Object function;           //function declaration
non terminal Object procedure;          //procedure declaration
non terminal Object funclist;           //list of function and procedure declarations
non terminal Object funccall;           //call a function
non terminal Object params;             //function or procedure parameters
non terminal Object attr;               //function or procedure attributes
non terminal Object type;               //variable type declaration

test ::= mult: m {:
    //m.printNode(1);
    //RESULT = m;
:};

program ::= PROGRAM ID:i decl:d funclist:fl BEGIN statementlist:sl END {::};

funclist ::= function:f funclist:fl {::}
    | procedure:p funclist:fl {::}
    | {::};

procedure ::= PROCEDURE ID:i PARIZQ params:p decl:d BEGIN statementlist:s END
    | PROCEDURE ID:i PARIZQ PARDER COLON type:t decl:d BEGIN statementlist:s END {::}; 

function ::= FUNCTION ID:i PARIZQ params:p COLON type:t decl:d BEGIN statementlist:s END
    | FUNCTION ID:i PARIZQ PARDER COLON type:t decl:d BEGIN statementlist:s END {::};

funccall ::= ID:i PARIZQ attr:at {::};

attr ::= math:m COMA attr:a {::}
    | rel:r COMA attr:a {::}
    | CONSTCHAR:cc COMA attr:a {::}
    | CONSTSTR:cc COMA attr:a {::}
    | math:m PARDER {::}
    | rel:r PARDER {::}
    | CONSTCHAR:cc PARDER{::}
    | CONSTSTR:cc PARDER{::};

params ::= ID:i COMA params:p {::}
    | ID:i COLON type:t COMA params:p {::}
    | ID:i COLON type:t PARDER {::};

type ::= INT {::}
    | CHAR {::}
    | BOOLEAN {::}
    | RECORD {::}
    | STRING {::};

statement ::= BEGIN statementlist:sl END {::}
    | if:i {::}
    | while:w {::}
    | for:f {::}
    | repeat:r {::}
    | read:r {::}
    | write:w {::}
    | assig:a {::};

statementlist ::= statementlist:sl statement:s {::}
    | {::};

if ::= IF rel:r THEN statement:s {::}
    | IF rel:r THEN statement:si ELSE statement:se {::};

while ::= WHILE rel:r DO statement:s {::};

for ::= FOR ID:i ASSIG math:ma TO math:ml DO statement:s {::};

repeat ::= REPEAT statementlist UNTIL rel:r {::};

read ::= READ PARIZQ ID:i PARDER {::};

write ::= WRITE PARIZQ CONSTSTR:s PARDER {::}
    | WRITE PARIZQ CONSTSTR:s COMA ID:id PARDER {::};

decl ::= VAR ID:i multdecl:m{::}
    | {::};

multdecl ::= COMA ID:i multdecl:m {::}
    | COLON type:t {::};

assig ::= ID:i ASSIG CONSTSTR:cs {::}
    | ID:i ASSIG CONSTCHAR:cc {::}
    | ID:i ASSIG math:m {::}
    | ID:i ASSIG rel:r {::};

mathpar::= math:m PARDER {::};

math ::= sum:s {:
    //////////////// RETORNAR s ////////////////
    RESULT = s;
:};

sum ::= sum:s OPSUM:o mult:m {:
    //////////////// RETORNAR NUEO NODO MathSum (s, o, m) ////////////////
    RESULT = new MathSum(s, (String)o, m);
:} 
| mult:m {:
    //////////////// RETORNAR m ////////////////
    RESULT = m;
:};

/*

Value
    Obj num, bool, funccal, Id
    boolean not

num := Value | MathNode

MathMult
    Obj Value, MathNode, MathMult
    op
    Obj Value, MathNode, MathMult

mult := Value | MathNode | MathMult

MathSum
    Obj Value, MathNode, MathMult, MathSum
    op
    Obj Value, MathNode, MathMult, MathSum

sum := Value | MathNode | MathMult | MathSum

MathNode
    Obj Value, MathNode, MathMult, MathSum
    
math := Value | MathNode | MathMult | MathSum

*/


mult ::= mult:m OPMULT:o num:n {:
    //////////////// RETORNAR UN NUEVO NODO MathMultNode (m, o, n); ////////////////
    //MathMultNode number = new MathMultNode(n.intValue(),2); 
    RESULT = new MathMult(m,(String)o,n);

:}
| num:n {:
    //////////////// RETORNAR n ////////////////
    //RESULT = new MathMultNode(n.intValue(), 2);
    RESULT = n;
:};

num ::= NUMS:n {:
    RESULT = new Integer((String)n);
:}  
| PARIZQ math:m PARDER {:
    //////////////// AQUI SE DEBE VER QUE RETORNA MATH, SI ES UN MathNode RETORNAR MISMO MATHNODE, SINO, CREAR UN NUEVO MathNode DANDO COMO PARAMETRO m ////////////////
    if(m instanceof MathNode){
        RESULT = m;
    }else{
        RESULT = new MathNode(m);
    }
    //RESULT = m.intValue();
:}
| ID:i {:
    // ID 
    RESULT = (String)i;
:}
| funccall:fc {:
    //////////////// RETORNAR NUEVO NODO FuncCallNode ////////////////
:};

/*

BoolMathNode
    Object Value, MathNode, MathMult, MathSum
    String oprel
    Object Value, MathNode, MathMult, MathSum
    
boolmath::= BoolMathNode

Value
    Obj num, bool, funccal, Id
    boolean not

bool := Value | BoolNode | BoolMathNode

BoolAndNode
    Object  Value, BoolNode, BoolMathNode, BoolAndNode
    String operator
    Object  Value, BoolNode, BoolMathNode, BoolAndNode

booland := Value | BoolNode | BoolMathNode | BoolAndNode

BoolOrNode
    Object Value, BoolNode, BoolMathNode, BoolAndNode, BoolOrNode
    String operator
    Object Value, BoolNode, BoolMathNode, BoolAndNode, BoolOrNode

boolor := Value | BoolNode | BoolMathNode | BoolAndNode | BoolOrNode

BoolNode
    Object Value, BoolNode, BoolMathNode, BoolAndNode, BoolOrNode

rel := Value | BoolNode | BoolMathNode | BoolAndNode | BoolOrNode

*/


rel ::= boolor:b {:
    RESULT = b;
    //RESULT = b;
:};

boolor ::= boolor:r OPOR:o booland:b {:
    RESULT = new BoolOrNode(r,(String)o,b);
    //[oO][rR]
    //RESULT = new Boolean(r.booleanValue() || b.booleanValue());
:}
| booland:b {:
    RESULT = b;
    //RESULT = b.booleanValue();
:};

booland ::= booland:br OPAND:o bool:bl {:
    RESULT = new BoolAndNode(br,(String)o, bl);
    //[aA][nN][dD]
    //RESULT = new Boolean(br.booleanValue() && bl.booleanValue());
:}
| bool:b {:
    RESULT = b;
    //RESULT = b;
:};

bool ::= TRUE {:
    RESULT = new Boolean(true);
:} 
| FALSE {:
    RESULT = new Boolean(false);
:}
| ID:i {:
    RESULT = (String)i;
    ///////////////////////////////////////////////////////////////////////
:}
| NOT bool:b {:
    RESULT = new Value(b, true);
:}
| PARIZQ rel:r PARDER {:
    //RESULT = r;
:}
| boolmath:b {:
    //RESULT = b;
:};

boolmath ::= math:b OPREL:o math:m{:
    //<>|=|>|<|>=|<=
:};